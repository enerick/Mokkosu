#============================================================
#! @file    Stdlib.mok
#! @brief   Mokkosu 標準ライブラリ
#! @author  lamndataro, kielnow
#============================================================

__define "HIDE_TYPE";

import "mscorlib.dll";
import "System.dll";
import "System.Core.dll";
import "System.Drawing.dll";
import "System.Windows.Forms.dll";

using System;
using System.Drawing;
using System.Windows.Forms;
using System.Collections;

#------------------------------------------------------------
# システム関数
#------------------------------------------------------------

let error x = __prim "error" (x);
let undefined _ = error "undefined";
let ignore _ = ();

#------------------------------------------------------------
# 比較演算
#------------------------------------------------------------

let __operator_eqeq x y = __prim "eq" (x, y);
let __operator_ltgt x y = __prim "ne" (x, y);
let __operator_lt x y = __prim "lt" (x, y);
let __operator_gt x y = __prim "gt" (x, y);
let __operator_le x y = __prim "le" (x, y);
let __operator_ge x y = __prim "ge" (x, y);

let max x y = if x > y -> x else y;
let min x y = if x < y -> x else y;

#------------------------------------------------------------
# 整数演算
#------------------------------------------------------------

let __operator_pls x y = __prim "add" (x, y);
let __operator_mns x y = __prim "sub" (x, y);
let __operator_ast x y = __prim "mul" (x, y);
let __operator_sls x y = __prim "div" (x, y);
let __operator_per x y = __prim "mod" (x, y);
let __operator_neg x = 0 - x;

fun __operator_astast x y =
  if y == 0 -> 1
  else x * x ** (y - 1);

let succ x = x + 1;
let pred x = x - 1;
let abs x = if x >= 0 -> x else ~-x;

#------------------------------------------------------------
# ビット演算
#------------------------------------------------------------

let band x y = __prim "band" (x, y);
let bor x y = __prim "bor" (x, y);
let bxor x y = __prim "bxor" (x, y);
let bnot x = __prim "bnot" (x);
let bshr x y = __prim "bshr" (x, y);
let bshl x y = __prim "bshl" (x, y);
let bshrun x y = __prim "bshrun" (x, y);

#------------------------------------------------------------
# 浮動小数点数演算
#------------------------------------------------------------

let __operator_plsdot x y = __prim "fadd" (x, y);
let __operator_mnsdot x y = __prim "fsub" (x, y);
let __operator_astdot x y = __prim "fmul" (x, y);
let __operator_slsdot x y = __prim "fdiv" (x, y);

let __operator_negdot x = 0.0 -. x;

let fabs x = if x >= 0.0 -> x else ~-.x;

let pi = sget System.Math::PI;
let e = sget System.Math::E;

let sqrt x = call System.Math::Sqrt((x : Double));
let exp x = call System.Math::Exp((x : Double));
let log x = call System.Math::Log((x : Double));
let log10 x = call System.Math::Log10((x : Double));
let logn x y = call System.Math::Log((x : Double), (y : Double));
let pow x y = call System.Math::Pow((x : Double), (y : Double));

let sin x = call System.Math::Sin((x : Double));
let cos x = call System.Math::Cos((x : Double));
let tan x = call System.Math::Tan((x : Double));

let asin x = call System.Math::Asin((x : Double));
let acos x = call System.Math::Acos((x : Double));
let atan x = call System.Math::Atan((x : Double));
let atan2 x y = call System.Math::Atan2((x : Double), (y : Double));

let sinh x = call System.Math::Sinh((x : Double));
let cosh x = call System.Math::Cosh((x : Double));
let tanh x = call System.Math::Tanh((x : Double));

let ceiling x = call System.Math::Ceiling((x : Double));
let truncate x = call System.Math::Truncate((x : Double));
let round x = call System.Math::Round((x : Double));
let floor x = call System.Math::Floor((x : Double));

#------------------------------------------------------------
# 文字列演算
#------------------------------------------------------------

let __operator_hat x y = __prim "concat" (x, y);
let strlen (str : String) = str.get_Length();
let strnth (str : String) (idx : Int) = str.get_Chars(idx);

#------------------------------------------------------------
# 論理演算
#------------------------------------------------------------

let not = { true -> false; false -> true };
let xor (a : Bool) (b : Bool) = a <> b; 

#------------------------------------------------------------
# 変換
#------------------------------------------------------------

let int_to_string (n : Int) = __prim "tostring" (n);
let double_to_string (d : Double) = __prim "tostring" (d);
let char_to_string (c : Char) = __prim "tostring" (c);
let bool_to_string = { false -> "false"; true -> "true" };

let int = int_to_string;
let double = double_to_string;
let char = char_to_string;
let bool = bool_to_string;

let parse_int (s : String) = call Int32::Parse(s);
let parse_double (s : String) = call Double::Parse(s);

let int_to_double (n : Int) = call Convert::ToDouble(n);
let double_to_int (d : Double) = call Convert::ToInt32(d);
let int_to_char (n : Int) = call Convert::ToChar(n);
let char_to_int (c : Char) = call Convert::ToInt32(c);

let int_to_float (n : Int) = call Convert::ToSingle(n);
let float_to_int (f : {Single}) = call Convert::ToInt32(f);
let double_to_float (n : Double) = call Convert::ToSingle(n);
let float_to_double (f : {Single}) = call Convert::ToDouble(f);

let int_to_object (n : Int) = cast<Int32, Object>(n);
let double_to_object (d : Double) = cast<Double, Object>(d);
let bool_to_object (b : Bool) = cast<Boolean, Object>(b);
let char_to_object (c : Char) = cast<Char, Object>(c);

#------------------------------------------------------------
# 関数
#------------------------------------------------------------

let __operator_ltbar f x = f x;
let __operator_bargt x f = f x;
let __operator_ltlt f g x = f (g x);
let __operator_gtgt f g x = g (f x);
let match x f = f x;
let id x = x;
let const x y = x;
let flip f y x = f x y;

#------------------------------------------------------------
# Tuple
#------------------------------------------------------------

let fst (x, _) = x;
let snd (_, x) = x;

let curry f a b = f (a, b);
let uncurry f (a, b) = f a b;

#------------------------------------------------------------
# リファレンスセル
#------------------------------------------------------------

let ref x = __prim "ref" (x);
let __operator_bang x = __prim "deref" (x);
let __operator_coleq x y = __prim "assign" (x, y);

#------------------------------------------------------------
# リスト
#------------------------------------------------------------

fun __operator_dotdot x y =
  if x > y -> []
  else x :: (x + 1) .. y;

fun __operator_plspls xs ys =
  match xs {
    [] -> ys;
	hd :: tl -> hd :: (tl ++ ys);
  };

fun length lis =
  match lis {
    [] -> 0;
	_ :: xs -> 1 + length xs;
  };

fun reverse lis =
  match lis {
    [] -> [];
	x :: xs -> reverse xs ++ [x];
  };

fun map f = {
  [] -> [];
  x :: xs -> f x :: map f xs;
};

fun filter p = {
  [] -> [];
  x :: xs ? p x -> x :: filter p xs;
  _ :: xs -> filter p xs;
};

let head (x :: _) = x;
let tail (_ :: xs) = xs;

fun last lis =
  match lis {
    [x] -> x;
	_ :: xs -> last xs;
  };

fun init lis =
  match lis {
    [x] -> [];
	x :: xs -> x :: init xs; 
  };

fun nth n lis =
  if n == 0 -> head lis
  else nth (n - 1) (tail lis);

let null = { [] -> true; _ -> false };

fun foldl f seed = {
  [] -> seed;
  x :: xs -> foldl f (f seed x) xs;
};

fun foldr f seed = {
  [] -> seed;
  x :: xs -> f x (foldr f seed xs)
};

fun concat lis =
  match lis {
    [] -> [];
	x :: xs -> x ++ concat xs;
  };

let concatmap f lis = concat (map f lis); 

let __for_bind lis f = concatmap f lis;
let __for_unit x = [x];
let __for_zero = [];

# iter, take, drop, split_at, take_while, drop_while, elem, lookup, zip, zip_with, unzip がほしい

#------------------------------------------------------------
# 配列
#------------------------------------------------------------

let list_to_array lis =
  let alist = new ArrayList() in
  fun loop = {
    [] -> [];
	x :: xs -> do alist.Add((x : {Object})) in loop xs; 
  } in
  do loop (reverse lis) in
  alist.ToArray();

#------------------------------------------------------------
# リフレクション
#------------------------------------------------------------

let get_type (str : String) = call Type::GetType(str);

#------------------------------------------------------------
# メッセージ
#------------------------------------------------------------

let msgbox (str : String) =
  ignore (call MessageBox::Show(str));

#------------------------------------------------------------
# Color
#------------------------------------------------------------
type Color = RGBA(Int,Int,Int,Int)
           | RGB(Int,Int,Int)
           | FRGBA(Double,Double,Double,Double)
           | FRGB(Double,Double,Double)
           | HSVA(Double,Double,Double,Double)
           | HSV(Double,Double,Double);

#------------------------------------------------------------
# Convert to RGB/RGBA
#------------------------------------------------------------
fun toRGBA color =
  let toFF x = (double_to_int (round (255.0 *. x))) % 256 in
  match color {
    ~RGBA(r,g,b,a)  -> RGBA(r,g,b,a);
    ~RGB(r,g,b)     -> RGBA(r,g,b,0xff);
    ~FRGBA(r,g,b,a) -> RGBA(toFF r,toFF g,toFF b,toFF a);
    ~FRGB(r,g,b)    -> RGBA(toFF r,toFF g,toFF b,0xff);
    ~HSVA(h,s,v,a)  -> let ~RGBA(r,g,b,_) = toRGBA <| HSV(h,s,v) in RGBA(r,g,b,toFF a);
    ~HSV(h,s,v) -> 
      let c  = v *. s in
      let hh = (double_to_int (floor (h /. 60.0))) % 6 in
      let x  = c *. int_to_double (1 - abs (hh % 2 - 1)) in
      let vc = v -. c in
      let (r,g,b) = match hh {
        0 -> (vc+.c, vc+.x, vc  );
        1 -> (vc+.x, vc+.c, vc  );
        2 -> (vc,    vc+.c, vc+.x);
        3 -> (vc,    vc+.x, vc+.c);
        4 -> (vc+.x, vc,    vc+.c);
        5 -> (vc+.c, vc,    vc+.x);
        _ -> (vc,vc,vc);
      }
      in RGBA(toFF r,toFF g,toFF b,0xff);
  };
let toRGB c = let ~RGBA(r,g,b,_) = toRGBA c in RGB(r,g,b);

#------------------------------------------------------------
# Convert to FRGB/FRGBA
#------------------------------------------------------------
fun toFRGBA color =
  let fromFF x = int_to_double x /. 255.0 in
  match color {
    ~RGB(r,g,b)     -> FRGBA(fromFF r,fromFF g,fromFF b,1.0);
    ~RGBA(r,g,b,a)  -> FRGBA(fromFF r,fromFF g,fromFF b,fromFF a);
    ~HSV(_,_,_)     -> toFRGBA (toRGBA color);
    ~HSVA(_,_,_,_)  -> toFRGBA (toRGBA color);
    ~FRGB(r,g,b)    -> FRGBA(r,g,b,1.0);
    ~FRGBA(r,g,b,a) -> FRGBA(r,g,b,a);
  };
let toFRGB c = let ~FRGBA(r,g,b,_) = toFRGBA c in FRGB(r,g,b);

#------------------------------------------------------------
# Convert to HSV/HSVA
#------------------------------------------------------------
fun toHSVA color = match color {
  ~RGBA(r,g,b,a)  -> toHSVA (toFRGBA color);
  ~RGB(r,g,b)     -> toHSVA (toFRGBA color);
  ~HSVA(h,s,v,a)  -> HSVA(h,s,v,a);
  ~HSV(h,s,v)     -> HSVA(h,s,v,1.0);
  ~FRGBA(r,g,b,a) -> let ~HSVA(h,s,v,_) = toHSVA <| FRGB(r,g,b) in HSVA(h,s,v,a);
  ~FRGB(r,g,b) ->
    let mx = max (max r g) b in
    let mn = min (min r g) b in
    let mxn = mx -. mn in
    let h = if mn == b -> 60.0 *. (g -. r) /. mxn +. 60.0
       else if mn == r -> 60.0 *. (b -. g) /. mxn +. 180.0
       else if mn == g -> 60.0 *. (r -. b) /. mxn +. 300.0
       else 0.0
    in
    let s = mx in
    let v = mxn /. mx
    in HSVA(h,s,v,1.0);
};
let toHSV c = let ~HSVA(h,s,v,_) = toHSVA c in HSV(h,s,v);

#------------------------------------------------------------
# ウインドウ
#------------------------------------------------------------

let _timer = new Timer();

let set_inserval (n : Int) =
  _timer.set_Interval(n);

let form = new Form();

do form.set_SizeGripStyle(sget SizeGripStyle::Hide);

do form.set_FormBorderStyle(sget FormBorderStyle::FixedSingle);

let set_title (str : String) =
  form.set_Text(str);

let set_size (w : Int) (h : Int) = 
  form.set_ClientSize(new Size(w, h));

let show_window () =
  form.ShowDialog();

let _cur_x = ref 0;
let _cur_y = ref 0;

let move x y = do _cur_x := x; _cur_y := y end;

let _font = new Font("ＭＳ ゴシック", 12);

type message = Draw({Graphics});

__undefine "HIDE_TYPE";
