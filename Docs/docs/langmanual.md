# 言語マニュアル

このマニュアルにはMokkosuのすべての機能が書かれていますが、
まだまだ分かりにくいところやあいまいなところがあるので、
今後改善していく予定です。

## 文
### do文
```
do 式;
```
do文は式を評価してその結果を捨てます。
キーワードのdoは省略することが可能です。

以下は画面に"Hello, World."と表示するプログラム例です。
```
println "Hello, World.";
```

### let文
```
let パターン = 式;
```
let文は式を評価してその結果をパターンにマッチさせます。

以下の文は式 2 + 3 の計算結果である 5 を変数 x に束縛します。
```
let x = 2 + 3;
```

### let文 (拡張形式)
```
let パターン パターン1 パターン2 ... = 式;
```
上の形式のlet文は以下のような形式に変換されます。
```
let パターン = \パターン1 パターン2 ... -> 式;
```

以下は引数の値を2倍する関数 double の定義例です。
```
let double x = x * 2;
```


### fun文
```
fun 関数名1 パターン11 パターン12 ... = 式1
and 関数名2 パターン21 パターン22 ... = 式2
...
and 関数名n パターンn1 パターンn2 ... = 式n;
```
fun文は相互再帰関数を定義する際に用います。

以下は階乗を計算する関数 fact の定義例です。
```
fun fact n =
  if n == 0 -> 1
  else n * fact (n - 1);
```

### type文
```
type 型名1 <型パラメータ11, ...> = タグ11(引数型11, ...) | ...
and  型名2 <型パラメータ21, ...> = タグ21(引数型21, ...) | ...;
```
type 文を使うとユーザ定義の型を定義できます。

以下は Yes または No という2つの値をもつ型 Answer の定義例です。
```
type Answer = Yes | Not;
```

以下は連結リストの定義例です。
```
type List<T> = Nil | Cons(T, List<T>);
```

### include文
```
include "ファイル名";
```
include文は指定したファイルを読み込み展開します。

以下は mylib.mok を読み込む例です。
```
include "mylib.mok";
```

### import文
```
import "DLL名";
```
import文は指定したDLLをプログラムに読み込みます。

以下は mydll.dll を読み込む例です。
```
import "mydll.dll";
```

### using文
```
using 名前空間;
```
using文は指定した.NETの名前空間を修飾なしで使えるように指定する文です。

以下は MyCompany.MyProduct 名前空間を using 文に指定した例です。
```
using MyCompany.MyProduct;
```

### __define文
```
__define "シンボル";
```
__define文は指定したシンボルを定義状態にします。
シンボルを定義することでコンパイラの動作を変更することができます。

以下はプログラムをデフォルトのウインドウズアプリケーションではなく、
コンソールアプリケーションとしてコンパイルする指定です。
```
__define "CONSOLE_APPLICATION";
```

### __undefine文
__undefine文は指定したシンボルを未定義状態にします。

以下の例ではシンボル"HIDE_TYPE"を用いることで、
変数 x の型の表示を抑止しています。
```
__define "HIDE_TYPE";
let x = 12;
__undefine "HIDE_TYPE";
```

## 式
### ラムダ式
```
\パターン1 パターン2 ... -> 式
```
ラムダ式を作ります。引数はカリー化されます。

以下は引数の値を2倍するラムダ式です。
```
\x -> x * 2
```

### if式
```
if 式1 -> 式2 else 式3
```
if式は式1が true であれば式2を評価した結果を返し、
式1が false であれば式3を評価した結果を返します。

以下は2つの引数のうち大きいものを返す関数 max の定義例です。
```
let max x y = if x > y -> x else y;
```

### pat式
```
pat パターン ? ガード = 式1 -> 式2 else 式3
```
pat文は式1を評価しパターンとマッチさせ、ガードを満たした場合は式2を評価した結果を返し、
パターンマッチに失敗するかガードを満たさなかった場合は式3を評価します。
? ガード の部分は省略可能です。

以下は整数のリストが空でない場合はリストの先頭要素を返し、
そうでない場合は指定されたデフォルト値を返す関数 hd の定義例です。
```
let hd list default =
  pat x :: _ = list -> x else default;
```

### do式
```
do 式1; 式2; ...; 式n; in 式
```
do式は式1から式nまでの式をを評価してそれぞれの結果を捨てて、
式の評価結果を返します。式nの後ろのセミコロンは省略できます。

以下の関数 f は引数の値を表示してその値をそのまま返します。
```
let f x = do println x in x;
```

### do式 (拡張形式)
```
do 式1; 式2; ...; 式n; end
```
上の式は以下の式に展開されます。
```
do 式1; 式2; ...; 式n; in ()
```

### let式
```
let パターン = 式1 in 式2
```
let式は式1を評価してパターンにマッチさせ式2を評価しその結果を返します。

### let式 (拡張形式)
```
let パターン パターン1 パターン2 ... = 式1 in 式2;
```
上の式は以下の式に展開されます。
```
let パターン = \パターン1 パターン2 ... -> 式1 in 式2;
```

### fun式
```
fun 関数名1 パターン11 パターン12 ... = 式1
and 関数名2 パターン21 パターン22 ... = 式2
...
and 関数名n パターンn1 パターンn2 ... = 式n
in 式
```
fun式は相互再帰関数を定義して式を評価します。

### ブロック式
```
{ ブロック構成子1; ... }
```
ブロック構成子には、パターンマッチ式の
```
パターン ? ガード -> 式
```
もしくは、以下のいずれかの形式がきます。
```
do 式
```
```
let パターン = 式
```
```
let パターン パターン1 パターン2 ... = 式
```
```
fun 関数名1 パターン11 パターン12 ... = 式1
and 関数名2 パターン21 パターン22 ... = 式2
...
and 関数名n パターンn1 パターンn2 ... = 式n
```
ブロック式は、
```
\新しい変数 -> ブロック構成子の列を変換したもの
```
という式に展開されます。

ブロック構成子がパターンマッチのとき、
```
pat パターン ? ガード = 新しい変数 -> 式
else 残りの構成子の列を変換したもの
```
という式に展開されます。

それ以外の場合は、対応する式に展開されます。
例えばdo式の場合は、
```
do 式 in 残りの構成子の列を変換したもの
```
という式に変換されます。

letとfunの場合も同様です。

残りの構成子の列が空の場合、
実行時エラーを生成する式になります。

### for式
```
for 列挙子1; 列挙子2; ... in 式;
```
列挙子には、
```
パターン <- 式;
```
もしくは、
```
if 式;
```
を指定します。

列挙子が パターン <- 式1 の場合、
```
__for_bind 式1 (\パターン -> 残りの列挙子の変換結果)
```
に展開されます。

列挙子が if 式1 の場合、
```
if 式1 -> __for_unit 残りの列挙子の変換結果 else __for_zero
```
に展開されます。

残りの列挙子が空の場合、残りの列挙子の変換結果は、
```
__for_unit 式
```
になります。

### コンス式
```
式1 :: 式2
```
評価するとリストになる式2の先頭に式1の評価結果を連結します。


### 論理積
```
式1 && 式2
```
式1と式2が両方ともtrueであればtrueを返します。
式1がfalseの場合、式2は評価されません。

### 論理和
```
式1 || 式2
```
式1と式2のいずれかがtrueであればtrueを返します。
式1がtrueの場合、式2は評価されません。

### 演算子
例えば
```
式1 + 式2
```
のような式は、
```
__operator_pls 式1 式2
という式に展開されます。
```

演算子には以下のものが定義されています。

|演算子    | 展開後の式             |
|----------|------------------------|
|式1 ** 式2| __operator_astast 式1 式2 |
|式1 << 式2| __operator_ltlt 式1 式2 |
|式1 >> 式2| __operator_gtgt 式1 式2 |
|式1 .. 式2| __operator_dotdot 式1 式2 |
|式1 * 式2| __operator_ast 式1 式2 |
|式1 / 式2| __operator_sls 式1 式2 |
|式1 % 式2| __operator_per 式1 式2 |
|式1 /. 式2| __operator_slsdot 式1 式2 |
|式1 *. 式2| __operator_astdot 式1 式2 |
|式1 + 式2| __operator_pls 式1 式2 |
|式1 - 式2| __operator_mns 式1 式2 |
|式1 +. 式2| __operator_plsdot 式1 式2 |
|式1 -. 式2| __operator_mnsdot 式1 式2 |
|式1 ++ 式2| __operator_plspls 式1 式2 |
|式1 ^ 式2| __operator_hat 式1 式2 |
|式1 < 式2| __operator_lt 式1 式2 |
|式1 > 式2| __operator_gt 式1 式2 |
|式1 <= 式2| __operator_le 式1 式2 |
|式1 >= 式2| __operator_ge 式1 式2 |
|式1 == 式2| __operator_eqeq 式1 式2 |
|式1 <> 式2| __operator_ltgt 式1 式2 |
|式1 := 式2| __operator_coleq 式1 式2 |
|式1 <&#124; 式2| __operator_ltbar 式1 式2 |
|式1 &#124;> 式2| __operator_bargt 式1 式2 |
|式1 $ 式2| __operator_doll 式1 式2 |
|式1 >>= 式2| __operator_gtgteq 式1 式2 |
|式1 =<< 式2| __operator_eqltlt 式1 式2 |
|式1 =< 式2| __operator_eqlt 式1 式2 |
|式1 <*> 式2| __operator_ltastgt 式1 式2 |
|式1 <* 式2| __operator_ltast 式1 式2 |
|式1 *> 式2| __operator_astgt 式1 式2 |
|式1 <+> 式2| __operator_ltplsgt 式1 式2 |
|式1 <+ 式2| __operator_ltpls 式1 式2 |
|式1 +> 式2| __operator_plsgt 式1 式2 |
|式1 <-> 式2| __operator_ltmnsgt 式1 式2 |
|式1 <&#124;> 式2| __operator_ltbargt 式1 式2 |
|式1 <$> 式2| __operator_ltdollgt 式1 式2 |
|式1 <**> 式2| __operator_ltastastgt 式1 式2 |
|式1 <** 式2| __operator_ltastast 式1 式2 |
|式1 **> 式2| __operator_astastgt 式1 式2 |
|式1 !! 式2| __operator_bangbang 式1 式2 |
|式1 ?? 式2| __operator_queque 式1 式2 |
|式1 *** 式2| __operator_astastast 式1 式2 |
|式1 &&& 式2| __operator_ampampamp 式1 式2 |
|式1 +++ 式2| __operator_plsplspls 式1 式2 |
|式1 &#124;&#124;&#124; 式2| __operator_barbarbar 式1 式2 |
|式1 -- 式2| __operator_mnsmns 式1 式2 |
|式1 --- 式2| __operator_mnsmnsmns 式1 式2 |
|~- 式| __operator_neg 式 |
|~-. 式| __operator_negdot 式 |
|! 式| __operator_bang 式 |

### 演算子の関数化
```
(演算子)
```
のように記述することで、演算子を関数に変換できます。

以下の3つの記述も可能です。
```
(::)
(&&)
(||)
```

### 関数の中値記法
```
式1 `関数名` 式2
```
上の式は以下のように展開されます。
```
関数名 式1 式2
```

### 型強制式
```
(式 : 型)
```
式が指定した型を持つことを強制します。

### call式
```
call クラス名::メソッド名(引数, ...)
```
.NETの静的メソッドを呼び出します。

### new式
```
new クラス名(引数, ...)
```
.NETのクラスのコンストラクタを呼び出してオブジェクトのインスタンスを
作成します。

### インスタンスメソッド呼び出し式
```
式 . メソッド名(引数, ...)
```
式のメソッドを呼び出します。

### フィールドアクセス式
```
set 式 . フィールド名 = 式
get 式 . フィールド名
```
インスタンスフィールドの値を設定したり値を取得したりします。

### 静的フィールドアクセス式
```
sset クラス::フィールド名 = 式
sget クラス::フィールド名
```
静的フィールドの値を設定したり値を取得したりします。

### delegate式
```
delegate クラス名 式
```
式(関数)を.NETのデリゲートに変換します。

### cast式
```
cast<クラス1, クラス2>(式)
```
式の型(クラス)をクラス1からクラス2にキャストします。

### プリミティブ呼び出し
```
__prim "プリミティブ名" 
```

## リテラル
### 整数リテラル
整数値は以下のような表記が可能です。
```
123
0xff
0o644
0b1101
```

### 浮動小数点数リテラル
浮動小数点値は以下のような表記が可能です。
```
3.14
24e-5
```

### 文字列
文字列リテラルは以下のように記述します。
```
"abc"
```
文字列中には以下のエスケープシーケンスを含めることができます。

|エスケープシーケンス    | 意味             |
|----------|------------------------|
| \' | 単一引用符 |
| \" | 二重引用符 |
| \\ | 円記号 |
| \0 | ヌル |
| \a | 警告 |
| \b | バックスペース |
| \f | フォームフィード |
| \n | 改行 |
| \r | キャリッジリターン }
| \t | 水平タブ |
| \uxxxx | ユニコード文字 |
| \v | 垂直タブ |

### 文字リテラル
文字リテラルはいかのように記述します。
```
'A'
```
文字列と同様のエスケープシーケンスを利用できます。

### 真偽値リテラル
真偽値リテラルは
```
true
```
と
```
false
```
の2種類の値をもちます。

### ユニットリテラル
ユニットリテラルは、以下のように記述します。
```
()
```

以下のように中身が空の拡張形式のdo式はユニットリテラル
の代わりとして利用できます。
```
do end
```

### リストリテラル
リストは以下のように記述します。
```
[1, 2, 3]
```

空のリストは、
```
[]
```
と書きます。

### タプルリテラル
```
("x", 123)
```

## パターン
### ワイルドカードパターン
```
_
```

### 変数パターン
```
x
```

### リテラルパターン
```
1
3.14
"abc"
'A'
()
true
```

### ユーザ定義タグパターン
```
~Yes
~Cons(x, y)
```

### リストパターン
```
[x, y, z]
```

### タプルパターン
```
(x, y)
```

### コンスパターン
```
x :: xs
```

### asパターン
```
(x :: xs) as lis
```

### orパターン
```
(1, _) | (0, 1)
```

### 型強制パターン
```
(x : Int)
```

## その他
### 識別子
変数名、関数名、型名、type文のタグ名は、
アルファベットまたは数値またはアンダースコアの列である必要が
あります。ただし最初の1文字はアルファベットまたは
アンダースコアである必要があります

以下に掲げるキーワードと同じ名前の識別子を利用することは
できません。

### コメント
コメントには、`#`で始まる単一行コメント
```
# 単一行コメント
```
と`#[`で始まり`#]`で終わる複数行コメントがあります。
```
#[
複数行コメント
#]
```
があります。

### プリミティブ関数
|プリミティブ関数名    | 機能             |
|----------|------------------------|
| add | 整数加算 |
| sub | 整数減算 |
| mul | 整数乗算 |
| div | 整数除算 |
| mod | 整数剰余 |
| band | ビットごとのAND |
| bor | ビットごとのOR |
| bxor | ビットごとのXOR |
| bshr | 算術右シフト |
| bshrun | 論理右シフト |
| bshl | 左シフト |
| bnot | ビットの反転 |
| fadd | 浮動小数点数加算 |
| fsub | 浮動小数点数減算 |
| fmul | 浮動小数点数乗算 |
| fdiv | 浮動小数点数除算 |
| eq | 比較(等しい) |
| ne | 比較(等しくない) |
| lt | 比較(より小さい) |
| gt | 比較(より大きい) |
| le | 比較(以下) |
| ge | 比較(以上) |
| concat | 文字列連結 |
| print | 値の表示 |
| println | 値を表示して改行 |
| tostring | 値の文字列化 |
| error | 実行時エラーを発生させる |
| ref | リファレンスセルを作る |
| deref | リファレンスセルの値を取り出す |
| assign | リファレンスセルへの代入 |
| loadnull | null値を生成する |
| intequal | 強制的に整数として値の等しさを調べる |

### コンパイラシンボル
|シンボル    | 役割             |
|----------|------------------------|
| "CONSOLE_APPLICATION" | コンソールアプリケーションとしてコンパイルする |
| "HIDE_TYPE" | 型の表示を抑制する |
| "SHOW_PARSE_RESULT" | 構文解析・型推論結果を表示する |
| "SHOW_CLOSURE_RESULT" | クロージャ変換の結果を表示する |
